CREATE TABLE funcionarios (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50),
    cargo VARCHAR(50),
    salario DECIMAL(10,2),
    departamento_id INT
);

INSERT INTO funcionarios (nome, cargo, salario, departamento_id) VALUES
('Ana', 'Analista', 3500, 1),
('Bruno', 'Gerente', 7000, 2),
('Carlos', 'Desenvolvedor', 4200, 1),
('Diego', 'Diretor', 10000, 3),
('Elisa', 'Analista', 3200, 1),
('Fernanda', 'Gerente', 7500, 2),
('Gabriel', 'Desenvolvedor', 4800, 1),
('Hugo', 'Analista', 3600, 3)
('null', 'Analista', 3600, 3);

CREATE TABLE departamentos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50),
    localizacao VARCHAR(50)
);

INSERT INTO departamentos (nome, localizacao) VALUES
('TI', 'S√£o Paulo'),
('RH', 'Rio de Janeiro'),
('Financeiro', 'S√£o Paulo');
--------------------------------------------------------------------------


--Exerc√≠cios:

--B√°sico: Liste todos os funcion√°rios (nome, cargo, sal√°rio) do departamento de TI.

SELECT 
nome,
cargo,
salario
FROM funcionarios
WHERE departamento_id = '1' --(SELECT id FROM departamentos WHERE nome = 'TI');


--B√°sico: Liste o nome e o sal√°rio dos funcion√°rios que ganham mais de R$ 4.000.

SELECT nome, salario
FROM funcionarios
WHERE salario > '4000'

--B√°sico: Liste todos os departamentos e suas localiza√ß√µes.

-- primeiro modo
SELECT nome, localizacao
FROM departamentos


-- segundo modo
SELECT * FROM departamentos

--B√°sico: Liste os funcion√°rios que s√£o Analistas ou Desenvolvedores.

SELECT nome
FROM funcionarios
WHERE cargo = 'Analista' OR cargo = 'Desenvolvedor'

--Intermedi√°rio: Liste o nome dos funcion√°rios e o nome do departamento em que trabalham.

SELECT f.nome, d.nome AS departamento
FROM funcionarios f
JOIN departamentos d ON f.departamento_id = d.id

--Intermedi√°rio: Liste o nome dos funcion√°rios, seus cargos e o nome do departamento, ordenados por sal√°rio em ordem decrescente.

SELECT f.nome, f.cargo, f.salario, d.nome AS departamento
FROM funcionarios f
JOIN departamentos d ON f.departamento_id = d.id
ORDER BY f.salario DESC

--Intermedi√°rio: Encontre o sal√°rio m√©dio dos funcion√°rios do departamento de RH.

SELECT AVG(f.salario) AS salario_medio
FROM funcionarios f
INNER JOIN departamentos d ON f.departamento_id = d.id
WHERE d.nome = 'RH';


--Intermedi√°rio: Liste os departamentos que t√™m funcion√°rios com sal√°rio superior a R$ 5.000.

SELECT DISTINCT d.nome
FROM departamentos d
INNER JOIN funcionarios f ON d.id = f.departamento_id
WHERE f.salario > 5000;


--Intermedi√°rio: Conte quantos funcion√°rios h√° em cada departamento. <<<< TREINAR MAIS !!!! 

SELECT d.nome, COUNT(f.departamento_id) AS quantidade
FROM funcionarios f
LEFT JOIN departamentos d ON f.departamento_id = d.id
GROUP BY f.departamento_id, d.nome

--Intermedi√°rio: Liste os funcion√°rios que trabalham em S√£o Paulo.

SELECT f.nome, d.localizacao 
FROM funcionarios f
JOIN departamentos d
ON d.localizacao = 'S√£o Paulo'
----------------------------------------------------------------------------
--TREINANDO COM WHERE

SELECT nome
FROM funcionarios
WHERE nome <> 'Ana';

SELECT nome, salario
FROM funcionarios
WHERE salario BETWEEN 3000 AND 5000


select nome
from funcionarios
where nome like 'A%';

select nome 
from funcionarios
where nome like '____'; 

select nome, cargo
from funcionarios
where cargo in ('Analista', 'Desenvolvedor');
 

select nome, cargo, salario
from funcionarios
where cargo = 'Analista' and salario > 2000;

select nome, cargo, salario
from funcionarios
where nome is null;


select nome, salario
from funcionarios
where salario > (select avg(salario) from funcionarios);


select nome, cargo, salario
from funcionarios
order by salario desc


select nome, cargo, salario
from funcionarios
order by nome asc, salario desc



select nome, salario, salario * 1.5 as aumento
from funcionarios
order by aumento desc



select distinct nome, cargo
from funcionarios

select nome, count(*) as total
from funcionarios
group by nome 

select count(distinct cargo) as cargos
from funcionarios



select nome
from funcionarios
where cargo in (
select distinct cargo
from funcionarios
where cargo <> 'Gerente'
);


select nome 
from funcionarios limit 3


select sum(f.salario) as total_salario
from funcionarios f

select cargo, sum(salario) as total_salario
from funcionarios
group by cargo
order by total_salario desc


select cargo, avg(salario) as media_salarial
from funcionarios
group by cargo

select cargo, avg(salario) as media_salario
from funcionarios
group by cargo
having avg(salario) > 5000;


select min(salario) as menor
from funcionarios


select
	cargo,
	count(*) as total_funcionarios,
	sum(salario) as total_salario,
	avg(salario) as media_salarial,
	min(salario) as salarioMinimo,
	max(salario) as salarioMaximo
from funcionarios
group by cargo;



select upper('cargo') as resultado;

select upper(nome), upper(cargo)
from funcionarios
where id = '1'


select lower(nome), lower(cargo)
from funcionarios
where id = '1'


select concat(nome, ' ', cargo) as NomeCargo
from funcionarios



select substring('Analista' from 0 for 4) as resultado;


select trim('              Ana Analista ') as resultado; -- TRIM remove os espa√ßos de ambos os lados

select ltrim('              Ana Analista ') as resultado; -- LTRIM remove os espa√ßos

select rtrim('    Ana Analista                 ') as resultado; -- RTRIM remove os espa√ßos


select now() as dataHora_atual

select current_timestamp


select '2025-02-19'::date + interval '1 day' as nova_data;

select now() + interval '10 days' ----DATEADD()

select now() - '1986-06-13' ---------DATEDIFF()


select extract(year from now()) as ano, 

	   extract(month from now()) as mes,

 	   extract(day from now()) as ano;


select cargo, sum(salario) as total_salario
from funcionarios 
group by cargo 
order by total_salario desc


select cargo, avg(salario) as mediaSalarial
from funcionarios
group by cargo
order by mediaSalarial desc


select cargo, min(salario)
from funcionarios
group by cargo


select d.nome, count(f.nome) as total
from departamentos d
left join funcionarios f on f.departamento_id = d.id
group by d.nome
having count(f.nome) < 3;

select cargo, avg(salario) as mediaSalarial
from funcionarios
group by cargo
having avg(salario) < 5000


-- Cria√ß√£o de tabelas mais elaboradas para treino de JOINs

-- Tabela de Departamentos
CREATE TABLE departamentos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50) NOT NULL,
    localizacao VARCHAR(50)
);

-- Tabela de Funcion√°rios
CREATE TABLE funcionarios (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50) NOT NULL,
    salario NUMERIC(10, 2),
    departamento_id INT,
    gerente_id INT,
    FOREIGN KEY (departamento_id) REFERENCES departamentos(id),
    FOREIGN KEY (gerente_id) REFERENCES funcionarios(id)
);

-- Tabela de Projetos
CREATE TABLE projetos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50) NOT NULL,
    departamento_id INT,
    FOREIGN KEY (departamento_id) REFERENCES departamentos(id)
);

-- Tabela de Funcion√°rios em Projetos (Relacionamento N:N)
CREATE TABLE funcionario_projeto (
    funcionario_id INT,
    projeto_id INT,
    PRIMARY KEY (funcionario_id, projeto_id),
    FOREIGN KEY (funcionario_id) REFERENCES funcionarios(id),
    FOREIGN KEY (projeto_id) REFERENCES projetos(id)
);

-- Inser√ß√£o de dados em Departamentos
INSERT INTO departamentos (nome, localizacao) VALUES
('TI', 'S√£o Paulo'),
('Recursos Humanos', 'Rio de Janeiro'),
('Financeiro', 'Belo Horizonte'),
('Marketing', 'S√£o Paulo');

-- Inser√ß√£o de dados em Funcion√°rios
INSERT INTO funcionarios (nome, salario, departamento_id, gerente_id) VALUES
('Alice', 7000.00, 1, NULL),
('Bruno', 4500.00, 1, 1),
('Carlos', 4000.00, 2, NULL),
('Diana', 5000.00, 3, NULL),
('Eduardo', NULL, NULL, NULL), -- Funcion√°rio sem departamento
('Fernanda', 6000.00, 4, NULL);

-- Inser√ß√£o de dados em Projetos
INSERT INTO projetos (nome, departamento_id) VALUES
('Sistema de Vendas', 1),
('Recrutamento 2025', 2),
('Auditoria Financeira', 3),
('Campanha Publicit√°ria', 4),
('Projeto Independente', NULL); -- Projeto sem departamento

-- Relacionamento entre Funcion√°rios e Projetos
INSERT INTO funcionario_projeto (funcionario_id, projeto_id) VALUES
(1, 1),
(2, 1),
(3, 2),
(4, 3),
(5, 4),
(2, 4); -- Bruno tamb√©m participa da campanha publicit√°ria



--INNER JOIN -- RETORNA APENAS OS DADOS IGUAIS EM AMBAS TABELAS

--DEPARTAMENTOS: id, nome, localizacao
--FUNCIONARIOS: id, nome, salario, FK: departamento_id, gerente_id
--PROJETOS: id, nome, FK: departamento_id 
--FUNCIONARIO_PROJETO: FK: funcionario_id, projeto_id

SELECT f.nome AS funcionario, p.nome AS projeto
FROM funcionarios f
INNER JOIN funcionario_projeto fp ON f.id = fp.funcionario_id
INNER JOIN projetos p ON fp.projeto_id = p.id;


select f.nome as funcionario, p.nome as projeto
from funcionarios f
inner join funcionario_projeto fp on fp.projeto_id = f.id
inner join projetos p on fp.projeto_id = p.id


select f.nome as funcionario, p.nome as projeto
from funcionarios f
left join funcionario_projeto fp on f.id = fp.funcionario_id
left join projetos p on fp.projeto_id = p.id


select f.nome, p.nome
from funcionarios f
left join projetos p on f.id = p.id


select f.nome as funcionario, p.nome as projeto
from funcionarios f
right join funcionario_projeto fp on f.id = fp.funcionario_id
right join projetos p on fp.funcionario_id = p.id


select f.nome as funcionario, p.nome as projeto
from funcionarios f
full outer join funcionario_projeto fp on f.id = fp.funcionario_id
full outer join projetos p on fp.projeto_id = p.id


select f1.nome as funcionario_1, f2.nome as funcionario_2, d.nome as departamento
from funcionarios f1
inner join funcionarios f2 on f1.departamento_id = f2.departamento_id
inner join departamentos d on f1.departamento_id = d.id
where f1.id <> f2.id


select f.nome, d.nome as departamento
from funcionarios f
inner join departamentos d
	on f.departamento_id = d.id
	and d.nome = 'TI'


select f.nome, d.nome as departamento
from funcionarios f
join departamentos d on f.departamento_id = d.id
where d.nome = 'TI'


select f.nome, p.nome as projeto
from funcionarios f
inner join projetos p
	using(departamento_id)


--DEPARTAMENTOS: id, nome, localizacao
--FUNCIONARIOS: id, nome, salario, FK: departamento_id, gerente_id
--PROJETOS: id, nome, FK: departamento_id 
--FUNCIONARIO_PROJETO: FK: funcionario_id, projeto_id


select localizacao from departamentos 
union
select nome from funcionarios

select nome, 'Antigo' as origem from funcionarios
union
select nome, 'Novo' as origem from departamentos
order by origem, nome;





CREATE DATABASE Empresa;


CREATE TABLE funcionarios (
    id_funcionario INT IDENTITY(1,1) PRIMARY KEY,
    nome_funcionario NVARCHAR(100) NOT NULL,
    salario DECIMAL(10, 2) NOT NULL,
    data_contratacao DATE NOT NULL,
    id_departamento INT,
    FOREIGN KEY (id_departamento) REFERENCES departamentos(id_departamento) ON DELETE CASCADE
);


INSERT INTO funcionarios (nome_funcionario, salario, data_contratacao, id_departamento)
VALUES 
    ('Robert Silva', 5000.00, '2020-10-01', 1),
    ('Edson Silva', 5000.00, '2020-01-15', 1),
    ('Maria Souza', 7200.00, '2018-03-22', 2),
    ('Carlos Mendes', 6000.00, '2019-07-10', 2),
    ('Ana Paula', 4500.00, '2021-05-01', 3),
    ('Pedro Almeida', 5500.00, '2017-11-12', 4),
    ('Juliana Santos', 8000.00, '2016-08-30', 5),
    ('Fernando Lima', 4800.00, '2022-02-14', 1),
    ('Camila Oliveira', 6200.00, '2020-09-05', 2),
    ('Rafael Costa', 5100.00, '2019-12-20', 3),
    ('Laura Ferreira', 7000.00, '2018-06-18', 5);  


insert into funcionarios (nome_funcionario, salario, data_contratacao, id_departamento)
values
	('Amanda Costa', 4800, '2025-03-15', 1),
	('Bruno Almeida', 6200, '2023-11-01', 2),
	('Carla Mendes', 5300,'2025-01-20', 3),
	('Diego Rocha', 7100, '2022-07-10', 2),
	('Eliane Martins',5900,'2024-09-05', 1);


	CREATE TABLE departamentos (
    id_departamento INT IDENTITY(1,1) PRIMARY KEY,
    nome_departamento NVARCHAR(100) NOT NULL
);


INSERT INTO departamentos (nome_departamento)
VALUES 
    ('Manutencao'),
    ('Recursos Humanos'),
    ('TI'),
    ('Financeiro'),
    ('Marketing'),
    ('Vendas');



--Query 1 : Retorne todos os funcion√°rios que trabalham no departamento de "TI".

Select 
	*
from 
	funcionarios f 
join departamentos d on f.id_departamento = d.id_departamento
where d.nome_departamento = 'TI';


select *
from 
	funcionarios
where 
	id_departamento = 2;


--Query 2 : Liste os funcion√°rios com sal√°rio superior a 6000.

select 
	nome_funcionario
from 
	funcionarios
where 
	salario > 6000;

--Query 3 : Encontre os funcion√°rios contratados ap√≥s 01/01/2020.

select
	nome_funcionario
from
	funcionarios
where 
	data_contratacao > '01/01/2020';

--Query 4 : Retorne os funcion√°rios cujo nome come√ßa com a letra "A".

select 
	*
from
	funcionarios
where 
	nome_funcionario like 'A%';

--Query 5 : Liste os funcion√°rios que ganham entre 5000 e 7000 (inclusive).

select
	*
from 
	funcionarios
where 
	salario between 5000 and 7000;


--Query 6 : Retorne os funcion√°rios que n√£o pertencem ao departamento de "Vendas".


select 
	*
from
	funcionarios
where
	id_departamento not like '5';
	

select 
	f.nome_funcionario,
	d.nome_departamento
from 
	funcionarios f
join 
	departamentos d on f.id_departamento = d.id_departamento
where 
	d.nome_departamento != 'Vendas';


--Query 7 : Encontre os funcion√°rios cujo nome cont√©m a palavra "Silva".

select
	* 
from 
	funcionarios
where 
	nome_funcionario like '%Silva%';

--Query 8 : Liste os funcion√°rios contratados no ano de 2019.

select
	* 
from 
	funcionarios
where 
	year(data_contratacao) = 2019;

--Query 9 : Retorne os funcion√°rios que t√™m sal√°rio exatamente igual a 5000.

select 
	* 
from 
	funcionarios
where 
	salario = 5000;

--Query 10 : Encontre os funcion√°rios cujo ID do departamento √© maior que 2.

select 
	* 
from 
	funcionarios
where 
	id_funcionario > 2;

--QUERIES NO WHERE COM IN

--Query 1 : Retorne os funcion√°rios que trabalham nos departamentos com IDs 2 ou 3.

select 
	* 
from 
	funcionarios
where 
	id_departamento in (2,3);

--Query 2 : Liste os funcion√°rios cujos nomes s√£o "Edson Silva" ou "Maria Souza".

select 
	*
from
	funcionarios
where 
	nome_funcionario in ('Edson Silva','Maria Souza');

--Query 3 : Encontre os funcion√°rios que ganham sal√°rios iguais a 5000, 6000 ou 7000.

select 
	*
from 
	funcionarios
where 
	salario in (5000, 6000, 7000);


--Query 4 : Retorne os funcion√°rios contratados em 2018, 2019 ou 2020.

select 
	* 
from 
	funcionarios
where 
	year(data_contratacao) in (2018,2019,2020); 


--Query 5 : Liste os funcion√°rios que pertencem aos departamentos "TI" ou "Financeiro".

select 
	*
from
	funcionarios f
	join departamentos d on f.id_departamento = d.id_departamento
where 
	d.nome_departamento in ('TI','Financeiro');


--Query 6 : Retorne os funcion√°rios que t√™m IDs 1, 4 ou 7.

select 
	* 
from 
	funcionarios
where 
	id_funcionario in (2,4,7);


--Query 7 : Encontre os funcion√°rios cujo nome come√ßa com "J" ou "M".


select 
	* 
from 
	funcionarios
where 
	left(nome_funcionario,1) in ('J','M', 'E') ;


--Query 8 : Liste os funcion√°rios que n√£o trabalham nos departamentos com IDs 1 ou 5.

select 
	*
from 
	funcionarios
where
	id_departamento not in (1,5);


--Query 9 : Retorne os funcion√°rios que foram contratados nos meses de janeiro, mar√ßo ou maio.


select 
	*
from 
	funcionarios
where month(data_contratacao) in (1,3,5);


--Query 10 : Encontre os funcion√°rios que ganham mais de 5000 e pertencem aos departamentos com IDs 2 ou 4.

select 
	top 2 nome_funcionario 
from 
	funcionarios
where 
	salario > 5000 and id_departamento in (2,4);



-- SUBQUERIES ESCALARES

--Exemplo 1 : Retorne os funcion√°rios que ganham mais que o sal√°rio m√©dio.

select *
from
	funcionarios
where 
	salario > (
		select 
			avg(salario)
			from funcionarios);

--Exemplo 3 : Retorne o departamento com o menor n√∫mero de funcion√°rios.

select *
from departamentos
where id_departamento = (
	select top 1 id_departamento
	from funcionarios
	group by id_departamento
	order by count(*) asc	
		);


--Exemplo 4 : Encontre o funcion√°rio contratado mais recentemente.

select 
	*
from 
	funcionarios
where 
	data_contratacao = (
		select max(data_contratacao)
		from funcionarios
		);

	
--Exemplo 5 : Retorne os funcion√°rios que t√™m o mesmo sal√°rio que "Edson Silva".

select
	*
from 
	funcionarios
where 
	salario = (
		select salario
		from funcionarios
		where nome_funcionario = 'Edson Silva'
		);


--2. Subqueries de Lista
--Exemplo 1 : Liste os funcion√°rios que pertencem aos departamentos "TI" ou "Vendas".

select *
from funcionarios
where id_departamento in (
	select id_departamento
	from departamentos
	where nome_departamento in ('TI','Vendas')
	);

--Exemplo 2 : Retorne os funcion√°rios que n√£o pertencem aos departamentos com IDs 1, 2 ou 3.

select *
from funcionarios
where id_departamento not in (1,2,3);

--Exemplo 3 : Encontre os departamentos que t√™m funcion√°rios com sal√°rios acima de 6000.

select *
from funcionarios
where id_departamento in (
    select id_departamento
	from funcionarios
	where salario > 6000
	);

--Exemplo 4 : Liste os funcion√°rios que trabalham nos departamentos com mais de 3 funcion√°rios.

select *
from funcionarios
where id_departamento in (
	select id_departamento
	from funcionarios
	group by id_departamento
	having count(*) >= 3
	);

--Exemplo 5 : Retorne os funcion√°rios que t√™m sal√°rios iguais a algum dos sal√°rios do departamento "Financeiro".


select *
from funcionarios
where salario in (
	select salario
	from funcionarios
	where id_departamento = (
		select id_departamento
		from departamentos
		where nome_departamento = 'Financeiro'
		)
	);

--3. Subqueries Correlacionadas

--Exemplo 1 : Retorne os funcion√°rios cujo sal√°rio √© maior que a m√©dia do seu pr√≥prio departamento.


SELECT f.* 
FROM funcionarios f
WHERE f.salario > (

    SELECT AVG(f2.salario) 
    FROM funcionarios f2 

    WHERE f2.id_departamento = f.id_departamento
);


--Exemplo 2 : Liste os funcion√°rios que t√™m sal√°rio maior que pelo menos um funcion√°rio do departamento "TI".

select *
from funcionarios
where salario > (
	select max(salario)
	from funcionarios
	where id_departamento in (
		select id_departamento
		from departamentos
		where nome_departamento = 'TI'
		)
	);

	SELECT f.* 
FROM funcionarios f
WHERE f.salario > ANY (
    SELECT f2.salario 
    FROM funcionarios f2 
    WHERE f2.id_departamento = (SELECT id_departamento FROM departamentos WHERE nome_departamento = 'TI')
);

--Exemplo 3 : Retorne os funcion√°rios que t√™m sal√°rio menor que todos os funcion√°rios do departamento "Vendas".

select *
from funcionarios
where salario < (
	select min(salario)
	from funcionarios
	where id_departamento in (
		select id_departamento
		from departamentos
		where nome_departamento = 'Vendas'
		)
	);


SELECT f.* 
FROM funcionarios f
WHERE f.salario < ALL (
    SELECT f2.salario 
    FROM funcionarios f2 
    WHERE f2.id_departamento = (SELECT id_departamento FROM departamentos WHERE nome_departamento = 'Vendas')
);



--Exemplo 4 : Liste os departamentos que t√™m funcion√°rios com sal√°rio superior √† m√©dia geral.


select nome_departamento
from departamentos d
where id_departamento in (

	select id_departamento
	from funcionarios
	where salario > (

		select avg(salario)
		from funcionarios f
		)
	);


--Exemplo 5: Retorne os funcion√°rios que t√™m sal√°rio igual ao de outro funcion√°rio no mesmo departamento.

select f1.*
from funcionarios f1
where exists (
	select 1
	from funcionarios f2
	where f1.id_funcionario != f2.id_funcionario
		and f1.id_departamento = f2.id_departamento
		and f1.salario = f2.salario
		);


--4. Subqueries com EXISTS

--O operador EXISTS verifica se a subquery retorna pelo menos uma linha.


select f.*
from funcionarios f
where exists (
	select 1
	from projetos_funcionarios pf
	where pf.id_funcionario = f.id_funcionario
	);

--Exemplo 2: Liste os departamentos que t√™m funcion√°rios.

select d.*
from departamentos d
where exists (
	select 1
	from funcionarios f
	where f.id_departamento = d.id_departamento
	);


--Exemplo 3: Retorne os funcion√°rios que n√£o t√™m projetos atribu√≠dos.

select f.*
from funcionarios f
where not exists (
	select 1
	from projetos_funcionarios pf
	where pf.id_funcionario = f.id_funcionario
	);

--Exemplo 4: Liste os departamentos que n√£o t√™m nenhum funcion√°rio.

select d.*
from departamentos d
where not exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	);

--Exemplo 5: Retorne os funcion√°rios que t√™m sal√°rio maior que algum funcion√°rio do departamento "TI".

select f.*
from funcionarios f
where exists (
	select 1
	from funcionarios f2
	where f2.id_departamento = (
		select id_departamento
		from departamentos
		where nome_departamento = 'TI'
		) and f.salario > f2.salario
	);

--listar os funcion√°rios cujo sal√°rio √© maior que a m√©dia do sal√°rio do seu pr√≥prio departamento


select f.*
from funcionarios f
where f.salario > (
	select avg(f2.salario)
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	);


--"Liste os funcion√°rios que t√™m sal√°rio menor que todos os sal√°rios do departamento 'Vendas'."


select f.*
from funcionarios f
where f.salario < All (
	select f2.salario
	from funcionarios f2
	where f2.id_departamento = (
		select id_departamento 
		from departamentos 
		where nome_departamento = 'Vendas'
		)
	);


select nome_funcionario
from funcionarios f
where exists (
	select 1
	from departamentos d
	where f.id_departamento = d.id_departamento
	);


--Fu√ß√µes no where

-- Fun√ß√£o Left()

select * 
from funcionarios
where LEFT(nome_funcionario,1)= 'R';

select *
from funcionarios
where LEFT(nome_funcionario, 2)= 'Ma'; 

select * 
from funcionarios
where LEFT(nome_funcionario, 3)='Eds'


--Fun√ß√£o Right()

select *
from funcionarios
where RIGHT(nome_funcionario, 1) = 'a';


select * 
from funcionarios
where RIGHT(nome_funcionario, 2) = 'ta';


select *
from funcionarios
where RIGHT(nome_funcionario, 2) ='Va';


--Fun√ß√£o Len()

select * 
from funcionarios
where LEN(nome_funcionario) = 11;

select *
from funcionarios
where LEN(nome_funcionario) > 12;

select *
from funcionarios
where LEN(nome_funcionario) < 10;


--Fun√ß√£o Upper()

select * 
from funcionarios
where left(UPPER(nome_funcionario),5) = 'Maria';

select *
from funcionarios
where UPPER(nome_funcionario) = 'EDSON SILVA';

select *
from funcionarios
where RIGHT(upper(nome_funcionario), 6) = 'Santos';


--Fun√ß√£o Lower()

SELECT * FROM funcionarios
WHERE LEFT(LOWER(nome_funcionario), 3) = 'ana';

SELECT * FROM funcionarios
WHERE LOWER(nome_funcionario) = 'robert silva';


SELECT * FROM funcionarios
WHERE RIGHT(LOWER(nome_funcionario), 5) = 'souza';


SELECT nome_funcionario
FROM funcionarios
WHERE nome_funcionario COLLATE Latin1_General_CI_AS = 'edson silva';


-- Treinando com Order By

--Liste todos os funcion√°rios em ordem alfab√©tica pelo nome.

select *
from funcionarios
order by nome_funcionario;

--- Liste os funcion√°rios em ordem decrescente de sal√°rio.

select *
from funcionarios
order by salario desc;

--Liste os funcion√°rios em ordem crescente pela data de contrata√ß√£o (do mais antigo para o mais recente).

select * 
from funcionarios
order by data_contratacao asc;


-- Liste os funcion√°rios em ordem decrescente pelo nome.

select * 
from funcionarios
order by nome_funcionario desc;

--- Liste os funcion√°rios primeiro por departamento (id_departamento) e depois por nome em ordem alfab√©tica.

select 
	id_departamento,
	nome_funcionario
from 
	funcionarios
order by 
	id_departamento,
	nome_funcionario;


--- Liste os funcion√°rios em ordem crescente pelo comprimento do nome.

select *
from funcionarios
order by LEN(nome_funcionario)desc;


--- Liste os funcion√°rios em ordem alfab√©tica considerando apenas o √∫ltimo caractere do nome.

select * 
from funcionarios
order by RIGHT(nome_funcionario,1) asc;


--- Liste os funcion√°rios em ordem alfab√©tica ignorando mai√∫sculas e min√∫sculas.

select *
from funcionarios
order by UPPER(nome_funcionario);

--- Liste os funcion√°rios em ordem crescente de sal√°rio e, em caso de empate, em ordem alfab√©tica pelo nome.

select *
from funcionarios
order by salario, nome_funcionario asc;


--- Liste os funcion√°rios em ordem decrescente pela data de contrata√ß√£o (do mais recente para o mais antigo).

select * 
from funcionarios
order by data_contratacao desc;


--Pagina√ß√£o de resultados - Offset/fetch

select nome_funcionario
from funcionarios
order by nome_funcionario
offset 3 rows fetch next 3 rows only;

--Ordena√ß√£o com express√µes


--Exemplo 1: Ordenar funcion√°rios pelo sal√°rio com aumento de 10%

select 
	nome_funcionario, 
	salario,
	salario * 1.1 as salario_ajustado
from 
	funcionarios
order by 
	salario * 1.1 desc;


/*
CONCAT() ‚Äî Jun√ß√£o de textos
üß† Teoria:
- Junta dois ou mais valores em uma √∫nica string.
- Substitui o uso do operador + para textos.
- Evita problemas com NULL (se algum valor for NULL, ele trata como string vazia).

üìò Sintaxe:

CONCAT(valor1, valor2, valor3, ...)

*/

--Exemplo 1: Mostrar nome completo com sal√°rio

SELECT CONCAT(nome_funcionario, ' - R$ ', salario) AS info_funcionario
FROM funcionarios;

select 
	CONCAT(nome_funcionario, ' - ', data_contratacao) As Info
from 
	funcionarios;

	
SELECT CONCAT(nome_funcionario, ' foi contratado em ', data_contratacao) AS resumo
FROM funcionarios;



/*
üìä O que s√£o Fun√ß√µes Agregadas?
Fun√ß√µes agregadas resumem ou calculam valores sobre um conjunto de linhas.
Elas s√£o usadas com ou sem GROUP BY, dependendo do contexto.

üß† Teoria:
- Conta o n√∫mero de linhas ou valores n√£o nulos.
- Pode contar * (todas as linhas) ou uma coluna espec√≠fica.
üß™ Exemplos:
*/

--Exemplo 1: Total de funcion√°rios

select count(*) TTfuncionarios
from funcionarios;


--Exemplo 2: Quantos funcion√°rios t√™m sal√°rio acima de R$ 6000

select count(*) as acima_6000
from funcionarios
where salario > 6000;

/*
2Ô∏è‚É£ SUM() ‚Äî Soma valores
üß† Teoria:
- Soma os valores de uma coluna num√©rica.
üß™ Exemplos:
*/

--Exemplo 1: Soma dos sal√°rios de todos os funcion√°rios

select sum(salario) as total_salarios
from funcionarios;


--Exemplo 2: Soma dos sal√°rios por departamento

select 
	id_departamento,
	sum(salario) PG_departamento
from 
	funcionarios
group by
	id_departamento;

/*
3Ô∏è‚É£ AVG() ‚Äî M√©dia
üß† Teoria:
- Calcula a m√©dia dos valores de uma coluna num√©rica.
üß™ Exemplos
*/

--Exemplo 1: M√©dia salarial geral

select avg(salario) Media_PG
from funcionarios;

select avg(salario) Media_DP
from funcionarios
group by id_departamento;


/*4Ô∏è‚É£ MIN() ‚Äî Valor m√≠nimo
üß† Teoria:
- Retorna o menor valor de uma coluna.
üß™ Exemplos
*/

--Exemplo 1: Menor sal√°rio da empresa

select min(salario) Menor_pg
from funcionarios;

--Exemplo 2: Menor sal√°rio por departamento

select 
	id_departamento, 
	min(salario) Menor_pg
from 
	funcionarios
group by 
	id_departamento;

/*
5Ô∏è‚É£ MAX() ‚Äî Valor m√°ximo
üß† Teoria:
- Retorna o maior valor de uma coluna.
üß™ Exemplos
*/

--Exemplo 1: Maior sal√°rio da empresa

select max(salario) as maior_salario
from funcionarios;

--Exemplo 2: Maior sal√°rio por departamento

select 
	id_departamento,
	max(salario) Maior_dp
from 
	funcionarios
group by id_departamento
order by id_departamento

--1. Contar quantos funcion√°rios existem em cada departamento

select 
	id_departamento,
	count(id_funcionario) qtd_func
from 
	funcionarios
group by id_departamento

--2. Contar quantos funcion√°rios foram contratados ap√≥s 2020

select 
	nome_funcionario,
	count(ID_funcionario) qtd_func
from 
	funcionarios
where data_contratacao > '2020-01-01'
group by nome_funcionario

select count(*) ctd_pos_2020
from funcionarios
where data_contratacao > '2020-01-01';


--3. Contar quantos nomes t√™m mais de 12 caracteres

select count(*) qtd_func
from funcionarios
where LEN(nome_funcionario) > 12;

--1. Soma dos sal√°rios por departamento

select
	id_departamento,
	sum(salario) soma_dp
from 
	funcionarios
group by id_departamento;  

--2. Soma dos sal√°rios de funcion√°rios contratados antes de 2020

select 
	sum(salario) Soma_pg
from 
	funcionarios
where year(data_contratacao) < '2020';


--3. Soma dos sal√°rios dos funcion√°rios cujo nome termina com 'a'

select 
	sum(salario) soma_pg
from 
	funcionarios
where RIGHT(nome_funcionario,1) = 'A';


--üìä AVG() ‚Äî M√©dia

--1. M√©dia salarial por departamento

select 
	id_departamento,
	avg(salario) Media_dp
from 
	funcionarios
group by id_departamento

--2. M√©dia salarial dos funcion√°rios contratados em 2020

select 
	AVG(salario) Media_2020
from 
	funcionarios
where year(data_contratacao) = '2020';


--3. M√©dia salarial dos funcion√°rios com nome maior que 10 caracteres

select 
	SUM(salario) Media_10
from 
	funcionarios
where LEN(nome_funcionario) > 10;

--üîΩ MIN() ‚Äî M√≠nim

--1. Menor sal√°rio por departamento

select 
	id_departamento,
	MIN(salario) Menor_sal
from 
	funcionarios
group by id_departamento
order by MIN(salario);

--2. Menor sal√°rio entre funcion√°rios contratados ap√≥s 2021

select
	MIN(salario) Menor_2021
from
	funcionarios
where 
	year(data_contratacao) > 2021;

--3. Menor sal√°rio entre funcion√°rios cujo nome come√ßa com 'C'

select 
	MIN(salario) Menor_c
from 
	funcionarios
where 
	LEFT(nome_funcionario, 1) = 'C';


--üîº MAX() ‚Äî M√°ximo
--1. Maior sal√°rio por departamento

select 
	id_departamento,
	MAX(salario) Maior_dp
from 
	funcionarios
group by 
	id_departamento


--2. Maior sal√°rio entre funcion√°rios contratados antes de 2019

select
	MAX(salario) Maior_2019
from 
	funcionarios
where 
	YEAR(data_contratacao) < 2019;

--3. Maior sal√°rio entre funcion√°rios cujo nome cont√©m 'Silva'

select 
	MAX(salario) Maior_sal
from 
	funcionarios
where 
	nome_funcionario like '%Silva%';


/*
‚öñÔ∏è Diferen√ßa entre WHERE e HAVING
| Cl√°usula | Quando √© usada | Atua sobre | Exemplo t√≠pico | 
| WHERE | Antes do agrupamento | Linhas individuais | WHERE salario > 5000 | 
| HAVING | Depois do agrupamento | Grupos de linhas | HAVING AVG(salario) > 6000 | 

üß† Regras principais
‚úÖ WHERE
- Filtra antes do GROUP BY.
- Atua sobre colunas normais.
- N√£o pode usar fun√ß√µes agregadas diretamente.
‚úÖ HAVING
- Filtra depois do GROUP BY.
- Atua sobre grupos.
- Pode usar fun√ß√µes agregadas como SUM(), AVG(), COUNT().  
*/


--üß™ Exemplos pr√°ticos
--üîπ Exemplo com WHERE ‚Äî Filtrar funcion√°rios com sal√°rio acima de 6000

select 
	nome_funcionario,
	salario
from 
	funcionarios
where 
	salario > 6000;

--üîπ Exemplo com HAVING ‚Äî Filtrar departamentos com m√©dia salarial acima de 6000

select 
	id_departamento,
	AVG(salario) Media_sal
from 
	funcionarios
group by 
	id_departamento
having 
	AVG(salario) > 6000;



--üß© 1. Listar os departamentos com mais de 10 funcion√°rios

select 
	id_departamento, 
	COUNT(*) as TT_func
from 
	funcionarios
group by 
	id_departamento
having COUNT(*) > 2;


--üß© 2. Listar os funcion√°rios que ganham mais de R$ 5.000

select 
	nome_funcionario,
	salario
from 
	funcionarios
where 
	salario > 5000;

--üß© 3. Listar os departamentos com m√©dia salarial acima de R$ 7.000

select 
	id_departamento,
	AVG(salario) Media_dp
from
	funcionarios
group by
	id_departamento
having AVG(salario) > 7000;


--üß© 4. Listar os departamentos com ID menor que 5

select 
	distinct id_departamento
from 
	funcionarios
where 
	id_departamento < 5;



--üß© 5. Listar os cargos com mais de 3 funcion√°rios que ganham acima de R$ 10.000

select 
	id_departamento,
	count(*) Qtd_func
from 
	funcionarios
where 
	salario > 4000
group by 
	id_departamento
having
	count(*) > 1; 
	
	
--CASE WHEN

--üß† O que √© CASE WHEN?

--O CASE WHEN √© uma estrutura condicional que permite avaliar valores e retornar resultados diferentes com base em regras.
--üìò Sintaxe b√°sica:


CASE 
    WHEN condi√ß√£o1 THEN resultado1
    WHEN condi√ß√£o2 THEN resultado2
    ELSE resultado_padr√£o
END


--Voc√™ pode usar isso em:

-- SELECT ‚Üí para criar colunas condicionais
-- ORDER BY ‚Üí para ordenar com l√≥gica personalizada
-- GROUP BY ‚Üí em casos mais avan√ßados
-- UPDATE ‚Üí para aplicar regras em altera√ß√µes

--üîß Exemplos pr√°ticos com sua tabela funcionarios

--‚úÖ 1. Classificar sal√°rios em faixas

SELECT 
    nome_funcionario,
    salario,
    CASE 
        WHEN salario < 5000 THEN 'Baixo'
        WHEN salario BETWEEN 5000 AND 7000 THEN 'M√©dio'
        ELSE 'Alto'
    END AS faixa_salarial
FROM funcionarios;


--üîç Aqui voc√™ cria uma nova coluna chamada faixa_salarial com base no valor do sal√°rio.

--‚úÖ 2. Identificar funcion√°rios contratados antes ou depois de 2020

SELECT 
    nome_funcionario,
    data_contratacao,
    CASE 
        WHEN data_contratacao < '2020-01-01' THEN 'Antigo'
        ELSE 'Recente'
    END AS tipo_contratacao
FROM funcionarios;


--üîç Isso te ajuda a segmentar os funcion√°rios por tempo de casa.

--‚úÖ 3. Aplicar b√¥nus condicional

SELECT 
    nome_funcionario,
    salario,
    CASE 
        WHEN salario < 5000 THEN salario * 1.10
        WHEN salario BETWEEN 5000 AND 7000 THEN salario * 1.05
        ELSE salario * 1.02
    END AS salario_com_bonus
FROM funcionarios;


--üîç Aqui voc√™ calcula um sal√°rio ajustado com b√¥nus, baseado em faixas.

--üß† Dica pr√°tica:
--O CASE WHEN funciona como um IF... ELSE dentro do SQL.
--Ele √© √≥timo para criar l√≥gica sem precisar alterar os dados da tabela.



--üéØ Desafios SQL (20 enunciados)

-- Liste os funcion√°rios com uma coluna que classifica o sal√°rio como "Baixo", "M√©dio" ou "Alto".

select 
	nome_funcionario,
	case
		when salario <= 4999 then 'Baixo'
		when salario between 5000 and 6000 then 'M√©dio'
		else 'Alto'	
		end Classe_sal
from 
	funcionarios;


-- Liste os funcion√°rios contratados antes de 2020 com uma coluna que diga "Antigo" ou "Recente".

select 
	nome_funcionario,
	data_contratacao,
	case 
		when data_contratacao < '2020' then 'Antigo'
		else 'Recente'
		end Classe_ano
from funcionarios;


-- Liste os funcion√°rios cujo nome termina com a letra "a".

select 
	nome_funcionario
from
	funcionarios
where 
	RIGHT(nome_funcionario, 1) = 'a'; 


-- Liste os departamentos com mais de 2 funcion√°rios.

select 
	id_departamento,
	count(*) cont
from
	funcionarios
group by 
	id_departamento 
having count(*) > 2;


-- Liste os funcion√°rios com sal√°rio acima da m√©dia geral da empresa.

select
	nome_funcionario,
	salario
from 
	funcionarios
where salario > (
	select AVG(salario)
	from funcionarios
	);

-- Liste os funcion√°rios com nome maior que 12 caracteres.

select 
	nome_funcionario
from 
	funcionarios
where 
	LEN(nome_funcionario) > 12;


-- Liste os departamentos com m√©dia salarial acima de R$ 6.000.

select 
	id_departamento
from 
	funcionarios
where salario > (
	select avg(salario)
	from funcionarios
	having AVG(salario) > 6000
	);


-- Liste os funcion√°rios com uma coluna que diga "TI", "RH", "Outros" com base no id_departamento.

select 
	nome_funcionario,
	case
		when id_departamento = 1 then 'RH'
		when id_departamento = 2 then 'TI'
		else 'Outros'
	end Departamentos
from 
	funcionarios


-- Liste os funcion√°rios com sal√°rio menor que R$ 5.000 e que foram contratados ap√≥s 2020.

select 
	nome_funcionario
from 
	funcionarios
where 
	salario < 5000 and
	YEAR(data_contratacao) > 2020;


-- Liste os departamentos com soma de sal√°rios superior a R$ 15.000.

select 
	id_departamento
from 
	funcionarios
group by 
	id_departamento
having	
	SUM(salario) > 15000;


-- Liste os funcion√°rios com uma coluna que diga "Eleg√≠vel para b√¥nus" se o sal√°rio for menor que R$ 6.000.

SELECT
	nome_funcionario,
	CASE 
		WHEN salario < 6000 THEN 'Eleg√≠vel para b√¥nus'
	END as B√¥nus
FROM 
	funcionarios;

-- Liste os funcion√°rios com nome que come√ßa com "C" ou "J".

SELECT
	nome_funcionario
FROM
	funcionarios
WHERE 
	LEFT(nome_funcionario, 1) = 'C' or
	LEFT(nome_funcionario, 1) = 'J';


-- Liste os departamentos com menos de 3 funcion√°rios que ganham acima de R$ 5.000.

select
	id_departamento,
	COUNT(*) contagem
from 
	funcionarios
WHERE 
	salario > 5000
group by 
	id_departamento
having 
	COUNT(*) < 3;

	
-- Liste os funcion√°rios com uma coluna que diga "Longo nome" ou "Nome curto" com base no n√∫mero de caracteres.

select
	nome_funcionario,
	case
		when len(nome_funcionario) < 13 then 'Nome curto'
		else 'Longo nome'
	end as Class_nome
from 
	funcionarios;

-- Liste os funcion√°rios com sal√°rio entre R$ 4.000 e R$ 6.000.

select 
	nome_funcionario,
	salario
from
	funcionarios
where 
	salario between 4000 and 6000;

-- Liste os departamentos com maior m√©dia salarial.


		
-- Liste os funcion√°rios com uma coluna que diga "Recente" se foram contratados ap√≥s 2021, sen√£o "Veterano".

select
	nome_funcionario,
	case
		when data_contratacao > '2021' then 'Recente'
		else 'Veterano'
	end as Classe_cont
from 
	funcionarios;


-- Liste os funcion√°rios com uma coluna que diga "Silva" se o nome contiver "Silva", sen√£o "Outro".

select
	nome_funcionario,
	case
		when nome_funcionario like '%Silva%' then 'Silva'
		else 'Outro'
	end as Sobrenome_silva
from 
	funcionarios;


-- Liste os departamentos com mais de 1 funcion√°rio cujo nome termina com "a".

select 
	id_departamento,
	COUNT(*) Contagem
from 
	funcionarios
where 
	 Right(nome_funcionario, 1) = 'A'
group by 
	id_departamento
having 
	COUNT(*) > 1;
 
-- Liste os funcion√°rios com uma coluna que diga "Alta remunera√ß√£o" se o sal√°rio for maior que R$ 7.000, sen√£o "Normal".

select 
	nome_funcionario,
	case
		when salario > 7000 then 'Alta remunera√ß√£o'
		else 'Normal'
	end as Classe_salarial
from 
	funcionarios;


/*
Revisar os fundamentos do CRUD √© uma excelente escolha ‚Äî mesmo quem j√° domina SQL precisa ter isso afiado, 
porque s√£o as opera√ß√µes que realmente manipulam os dados.

Vamos revisar cada uma com:
- ‚úÖ Teoria clara
- üß™ Exemplos pr√°ticos com a tabela funcionarios
- ‚ö†Ô∏è Dicas e cuidados comuns

üß± CRUD ‚Äî As 4 opera√ß√µes b√°sicas

| Opera√ß√£o | Comando SQL | Fun√ß√£o | 

| Create | INSERT INTO | Adiciona novos registros | 

| Read | SELECT | Consulta dados (j√° dominado por voc√™!) | 

| Update | UPDATE | Altera dados existentes | 

| Delete | DELETE | Remove registros | 



1Ô∏è‚É£ INSERT INTO ‚Äî Criar registros

üß† Teoria:
Adiciona uma nova linha na tabela.
üìò Sintaxe:
INSERT INTO funcionarios (nome_funcionario, salario, data_contratacao, id_departamento)
VALUES ('Carlos Silva', 5500, '2023-05-10', 2);

Ó∑ôÓ∑ö
‚ö†Ô∏è Dicas:
- Sempre respeite os tipos de dados (texto, n√∫mero, data).
- Se a tabela tiver uma coluna ID com IDENTITY, n√£o precisa inserir manualmente.

2Ô∏è‚É£ UPDATE ‚Äî Atualizar registros

üß† Teoria:
Modifica os dados de uma ou mais colunas de registros existentes.

üìò Sintaxe:
UPDATE funcionarios
SET salario = 6000
WHERE nome_funcionario = 'Carlos Silva';


‚ö†Ô∏è Dicas:
- Nunca esque√ßa o WHERE, ou voc√™ vai atualizar todos os registros da tabela.
- Pode atualizar m√∫ltiplas colunas:
SET salario = 6000, id_departamento = 3



3Ô∏è‚É£ DELETE ‚Äî Excluir registros

üß† Teoria:
Remove registros da tabela.

üìò Sintaxe:
DELETE FROM funcionarios
WHERE nome_funcionario = 'Carlos Silva';


‚ö†Ô∏è Dicas:
- Nunca use DELETE sem WHERE, a menos que voc√™ queira apagar tudo.
- Para apagar todos os dados com seguran√ßa:
DELETE FROM funcionarios WHERE 1 = 1;

*/


--Treinando com UPDATE 

Update funcionarios
set
	nome_funcionario = 'Edson Rocha',
	salario = 7200,
	id_departamento = 3
where id_funcionario = 2;


--üõ†Ô∏è Desafios com UPDATE
--1Ô∏è‚É£ Atualize o sal√°rio de todos os funcion√°rios do departamento 2, aumentando em 10%.
--Dica: use multiplica√ß√£o para calcular o novo valor.

Update funcionarios
set 
	salario = salario * 1.10
where id_departamento = 2;


--2Ô∏è‚É£ Altere o nome do funcion√°rio cujo sal√°rio √© exatamente R$ 5900 para "Fernanda Lima".
--Dica: use WHERE salario = 5900.

Update funcionarios
set 
	nome_funcionario = 'Fernanda Lima'
where salario = 5900;


--3Ô∏è‚É£ Transfira todos os funcion√°rios contratados antes de 2023 para o departamento 1.
--Dica: use WHERE data_contratacao < '2023-01-01'.

Update funcionarios
set 
	id_departamento = 1
where data_contratacao < '2023-01-01';


--4Ô∏è‚É£ Aumente o sal√°rio em R$ 500 de todos os funcion√°rios cujo nome termina com a letra "a".
--Dica: use RIGHT(nome_funcionario, 1) = 'a'.

Update funcionarios
set
	salario = salario + 500
where RIGHT(nome_funcionario, 1) = 'a';


--5Ô∏è‚É£ Atualize o nome e sal√°rio do funcion√°rio com id_funcionario = 5 para "Lucas Prado" e R$ 6800.
--Dica: atualize m√∫ltiplos campos no mesmo SET.

Update funcionarios
set
	nome_funcionario = 'Lucas Prado',
	salario = 6800
where id_funcionario = 5;



DELETE FROM funcionarios
WHERE nome_funcionario = 'Carlos Silva';


/*
üîó O que s√£o JOINS?
JOINS servem para combinar dados de duas ou mais tabelas com base em uma rela√ß√£o comum ‚Äî geralmente uma chave estrangeira.

üß≠ Entendendo LEFT, RIGHT e FULL JOIN
| Tipo de JOIN | O que retorna? | Quando usar? | 
| LEFT JOIN | Todos os registros da tabela da esquerda, e os correspondentes da direita. | Quando voc√™ precisa manter tudo da tabela principal, mesmo sem rela√ß√£o. | 
| RIGHT JOIN | Todos os registros da tabela da direita, e os correspondentes da esquerda. | Quando a tabela secund√°ria √© mais importante no contexto. | 
| FULL JOIN | Todos os registros de ambas as tabelas, com ou sem correspond√™ncia. | Quando voc√™ quer ver tudo, inclusive os que n√£o se relacionam. | 



üéì Exemplos com cen√°rio real de RH

Imagine duas tabelas:
- funcionarios
- departamentos

üü¢ LEFT JOIN
SELECT f.nome_funcionario, d.nome_departamento
FROM funcionarios f
LEFT JOIN departamentos d ON f.id_departamento = d.id_departamento;


üîç O que acontece?
Voc√™ ver√° todos os funcion√°rios, mesmo que alguns n√£o estejam vinculados a nenhum departamento (talvez o campo id_departamento esteja nulo ou inv√°lido).
üìå Use quando:
Quer garantir que ningu√©m fique de fora, mesmo que o dado complementar esteja faltando.

üîµ RIGHT JOIN
SELECT f.nome_funcionario, d.nome_departamento
FROM funcionarios f
RIGHT JOIN departamentos d ON f.id_departamento = d.id_departamento;


üîç O que acontece?
Voc√™ ver√° todos os departamentos, mesmo que nenhum funcion√°rio esteja alocado neles.
üìå Use quando:
Quer saber se h√° departamentos sem funcion√°rios ‚Äî √∫til para auditoria ou planejamento.

üü£ FULL JOIN
SELECT f.nome_funcionario, d.nome_departamento
FROM funcionarios f
FULL JOIN departamentos d ON f.id_departamento = d.id_departamento;


üîç O que acontece?
Voc√™ ver√° todos os funcion√°rios e todos os departamentos, inclusive os que n√£o t√™m rela√ß√£o entre si.
üìå Use quando:
Quer fazer uma an√°lise completa, inclusive de dados √≥rf√£os (sem v√≠nculo).

üß† Dica para memorizar
- LEFT = ‚ÄúQuero tudo da tabela principal (√† esquerda), mesmo que falte complemento.‚Äù
- RIGHT = ‚ÄúQuero tudo da tabela complementar (√† direita), mesmo que falte principal.‚Äù
- FULL = ‚ÄúQuero tudo de tudo, mesmo que n√£o se encaixe.‚Äù
*/

--Treinando JOINS
--üîç 1. Listar todos os funcion√°rios, mostrando tamb√©m o nome do departamento em que trabalham.
--Se o funcion√°rio n√£o estiver alocado em nenhum departamento, ainda assim deve aparecer na lista.

select 
	f.nome_funcionario,
	d.nome_departamento
from 
	funcionarios f
left join departamentos d on f.id_departamento = d.id_departamento;


--üîç 2. Exibir todos os departamentos, junto com os nomes dos funcion√°rios que est√£o alocados neles.
--Se um departamento n√£o tiver nenhum funcion√°rio, ele ainda deve aparecer.

select 
	d.nome_departamento,
	f.nome_funcionario
from 
	departamentos d 
left join funcionarios f on d.id_departamento = f.id_departamento;


--üîç 3. Mostrar todos os funcion√°rios e todos os projetos em que est√£o envolvidos.
--Se houver projetos sem funcion√°rios alocados, ou funcion√°rios sem projetos, ambos devem aparecer.

select 
	f.nome_funcionario,
	p.nome_projeto 
from 
	funcionarios f 
full join projetos p on f.id_funcionario = p.id_funcionario;
--obs: tabela de projetos ficticia
	


--üîç 4. Listar todos os clientes e os pedidos que eles fizeram.
--Se algum cliente ainda n√£o fez pedido, ele deve aparecer mesmo assim.

select 
	c.cliente,
	p.pedido
from 
	clientes c
left join pedidos p on c.id_cliente = p.id_cliente;
--obs: tabelas ficticias



--üîç 5. Exibir todos os produtos e os fornecedores que os entregam.
--Se houver fornecedores cadastrados que ainda n√£o entregaram nenhum produto, eles devem aparecer.

select 
	p.produto,
	f.fornecedor
from	
	produtos p 
left join fornecedores f on p.produto_id = f.fornecedor_id


--üîç 6. Mostrar todos os funcion√°rios e os treinamentos que participaram.
--Se houver treinamentos sem nenhum participante, ou funcion√°rios que n√£o participaram de nenhum, todos devem aparecer.

select 
	f.nome_funcionario,
	t.treinamento
from 
	funcionarios f
full join treinamento t on f.id_funcionario = t.id_funcionario;

/*
üß† O que s√£o Subqueries?
Subqueries (ou "consultas internas") s√£o consultas aninhadas dentro de outra consulta principal. Elas podem aparecer em:

- SELECT ‚Üí para calcular valores din√¢micos
- FROM ‚Üí para criar tabelas tempor√°rias
- WHERE ‚Üí para filtrar com base em resultados de outra consulta

üîç 1. Subquery no SELECT
üìò Exemplo:
SELECT 
    nome_funcionario,
    salario,
    (SELECT AVG(salario) FROM funcionarios) AS media_salarial
FROM funcionarios;


üîé O que faz?
- Para cada linha, mostra o sal√°rio do funcion√°rio e a m√©dia salarial da empresa.
- A subquery calcula a m√©dia uma vez, e o valor aparece em todas as linhas.
üìå Use quando:
Quer trazer valores agregados ou comparativos junto com os dados principais.

üîç 2. Subquery no FROM
üìò Exemplo:

SELECT nome_departamento, total_funcionarios
FROM (
    SELECT id_departamento, COUNT(*) AS total_funcionarios
    FROM funcionarios
    GROUP BY id_departamento
) AS resumo
JOIN departamentos ON resumo.id_departamento = departamentos.id_departamento;


üîé O que faz?
- Cria uma "tabela tempor√°ria" chamada resumo com total de funcion√°rios por departamento.
- Junta essa tabela com departamentos para mostrar os nomes.
üìå Use quando:
Quer tratar agrupamentos ou c√°lculos como se fossem uma tabela.

üîç 3. Subquery no WHERE
üìò Exemplo:

SELECT nome_funcionario, salario
FROM funcionarios
WHERE salario > (
    SELECT AVG(salario) FROM funcionarios
);


üîé O que faz?
- Filtra os funcion√°rios cujo sal√°rio √© maior que a m√©dia da empresa.
üìå Use quando:
Quer filtrar dados com base em valores din√¢micos ou exist√™ncia de registros.

üß† Dicas pr√°ticas
- Subqueries no SELECT s√£o √≥timas para compara√ß√µes.
- Subqueries no FROM s√£o ideais para relat√≥rios complexos.
- Subqueries no WHERE s√£o perfeitas para filtros inteligentes.
*/


--üîç Subqueries no SELECT (2 exerc√≠cios)
--1Ô∏è‚É£ Liste o nome de cada funcion√°rio e, ao lado, a m√©dia salarial da empresa.

select
	nome_funcionario,
	(select AVG(salario) from funcionarios) Media_sal
from 
	funcionarios;

--2Ô∏è‚É£ Liste o nome de cada departamento e, ao lado, o total de funcion√°rios da empresa.

select 
	d.nome_departamento,
	Tab.total_func
from (
	select id_departamento, COUNT(*) total_func
	from funcionarios
	group by id_departamento
) as Tab
join departamentos d on Tab.id_departamento = d.id_departamento


--üîç Subqueries no WHERE (2 exerc√≠cios)
--3Ô∏è‚É£ Liste os funcion√°rios que ganham mais que a m√©dia salarial do seu pr√≥prio departamento.
--Dica: voc√™ vai precisar de uma subquery que calcule a m√©dia por id_departamento.

select 
	f.nome_funcionario,
	f.salario
from 
	funcionarios f
where f.salario > (
	select AVG(f2.salario)
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	);
	

--4Ô∏è‚É£ Liste os departamentos que t√™m pelo menos um funcion√°rio com sal√°rio acima de R$ 7000.
--Dica: use WHERE EXISTS ou IN com subquery.

select 
	id_departamento,
	COUNT(*) Qtd
from 
	funcionarios
where exists (
	select 1
	from funcionarios
	where salario > 7000
	)group by id_departamento;


--üîç Subqueries no FROM (2 exerc√≠cios)
--5Ô∏è‚É£ Liste os nomes dos departamentos e a quantidade de funcion√°rios em cada um, usando uma subquery no FROM.
--Dica: a subquery deve agrupar por id_departamento e contar os funcion√°rios.

select
	d.nome_departamento,
	qtd.total_func
from (
	select id_departamento, COUNT(*) total_func
	from funcionarios
	group by id_departamento
	) as qtd
join departamentos d on qtd.id_departamento = d.id_departamento;


--6Ô∏è‚É£ Liste os nomes dos funcion√°rios e o total de sal√°rio por departamento, usando subquery no FROM.
--Dica: a subquery calcula SUM(salario) por departamento, e voc√™ junta com funcionarios.

select 
	f.nome_funcionario,
	tt.sal
from (
	select f2.id_departamento, SUM(f2.salario) sal
	from funcionarios f2 
	group by f2.id_departamento
	) as tt
join funcionarios f on f.id_departamento = tt.id_departamento



--üîç Subqueries no FROM (5 exerc√≠cios)

--1Ô∏è‚É£ Total de sal√°rio por departamento + nome do departamento
--Objetivo: Mostrar o nome de cada departamento e o total de sal√°rios pagos nele.
--Dica: Subquery no FROM com SUM(salario) agrupado por id_departamento.

select 
	d.nome_departamento,
	tab.ttsal
from (
	select id_departamento, SUM(salario) ttsal
	from funcionarios f
	group by id_departamento
	) as tab
join departamentos d on d.id_departamento = tab.id_departamento



--2Ô∏è‚É£ M√©dia salarial por departamento + nome dos funcion√°rios
--Objetivo: Mostrar o nome de cada funcion√°rio e a m√©dia salarial do seu departamento.
--Dica: Subquery no FROM calcula m√©dia por id_departamento, depois faz JOIN com funcionarios.

select 
	f.nome_funcionario,
	Med.sal
from (
	select id_departamento, AVG(salario) sal
	from funcionarios
	group by id_departamento
	) Med
join funcionarios f on f.id_departamento = Med.id_departamento;



--3Ô∏è‚É£ Departamentos com mais de 3 funcion√°rios
--Objetivo: Mostrar nome dos departamentos que t√™m mais de 3 funcion√°rios.
--Dica: Subquery no FROM conta funcion√°rios por departamento, depois filtra com WHERE total_func > 3.


select 
	f.id_departamento,
	tt.func
from ( 
	select id_departamento, COUNT(*) func
	from funcionarios
	group by id_departamento
	
	) tt
join funcionarios f on f.id_departamento = tt.id_departamento
where tt.func > 3
group by tt.func, f.id_departamento;



--4Ô∏è‚É£ Funcion√°rios com sal√°rio acima da m√©dia geral
--Objetivo: Mostrar nome e sal√°rio dos funcion√°rios que ganham mais que a m√©dia da empresa.
--Dica: Subquery no FROM calcula AVG(salario) e voc√™ cruza com funcionarios.

select
	f.nome_funcionario,
	f.salario
from (
	select id_departamento, AVG(salario) med
	from funcionarios
	group by id_departamento
	) sal
join funcionarios f on f.id_departamento = sal.id_departamento
where f.salario > sal.med;


--5Ô∏è‚É£ Funcion√°rios e a soma de sal√°rios do departamento deles
--Objetivo: Mostrar nome do funcion√°rio e a soma de sal√°rios do seu departamento.
--Dica: Subquery no FROM com SUM(salario) por id_departamento, depois JOIN com funcionarios.

select 
	f.nome_funcionario,
	soma.sal
from (
	select id_departamento, SUM(salario) sal
	from funcionarios 
	group by id_departamento
	) soma
join funcionarios f on f.id_departamento = soma.id_departamento;


--üîç Subqueries com EXISTS (3 exerc√≠cios)
--1Ô∏è‚É£ Departamentos com pelo menos um funcion√°rio com sal√°rio abaixo de R$ 3000
--Objetivo: Mostrar nome dos departamentos que t√™m funcion√°rios com sal√°rio < 3000.
--Dica: Use EXISTS com subquery correlacionada que compara id_departamento.

select 
	id_departamento,
	salario
from 
	funcionarios
where exists (
	select 1
	from funcionarios
	where salario < 5000
	group by id_departamento
	)order by id_departamento;

	SELECT d.nome_departamento
FROM departamentos d
WHERE EXISTS (
    SELECT 1
    FROM funcionarios f
    WHERE f.id_departamento = d.id_departamento
      AND f.salario < 5000
);


--2Ô∏è‚É£ Funcion√°rios que trabalham em departamentos com mais de 5 pessoas
--Objetivo: Mostrar nome dos funcion√°rios que est√£o em departamentos com mais de 5 funcion√°rios.
--Dica: Subquery com COUNT(*) por id_departamento, e EXISTS para verificar se o departamento do funcion√°rio atende √† condi√ß√£o.

select
	id_departamento,
	nome_funcionario
from 
	funcionarios
where exists (
	select 1
	from funcionarios
	group by id_departamento
	having COUNT(*) > 5
	);


--3Ô∏è‚É£ Departamentos que n√£o t√™m nenhum funcion√°rio com sal√°rio acima de R$ 10.000
--Objetivo: Mostrar nome dos departamentos onde ningu√©m ganha mais que 10 mil.
--Dica: Use NOT EXISTS com subquery correlacionada.


select 
	d.nome_departamento
from 
	departamentos d
where not exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	and f.salario > 7000
	);


--üß™ Enunciados: Subqueries Correlacionadas
-- Liste os nomes dos departamentos onde nenhum funcion√°rio ganha mais que 10 mil.

select 
	d.nome_departamento
from 
	departamentos d
where not exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	and f.salario > 6000
	);



select 
	d.nome_departamento
from	
	departamentos d
where not exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	and f.salario > 5000
	);

-- Liste os nomes dos funcion√°rios que ganham mais que a m√©dia salarial do seu pr√≥prio departamento.


select	
	f.nome_funcionario
from 
	funcionarios f
where 
	f.salario > (
	select AVG(f2.salario)
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	);



select 
	f.nome_funcionario
from 
	funcionarios f
where exists (
	select 1
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	group by f2.salario
	having f2.salario > AVG(f2.salario)
	);

	SELECT f.nome_funcionario
FROM funcionarios f
WHERE f.salario > (
    SELECT AVG(f2.salario)
    FROM funcionarios f2
    WHERE f2.id_departamento = f.id_departamento
);

-- Liste os nomes dos departamentos que possuem pelo menos um funcion√°rio com sal√°rio inferior a 3000.

select 
	d.nome_departamento
from
	departamentos d 
where exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	and f.salario < 5000
	);
-- Liste os nomes dos funcion√°rios que trabalham em departamentos onde h√° outro funcion√°rio com sal√°rio maior que o deles.

select 
	f.nome_funcionario
from 
	funcionarios f
where exists (
	select 1 
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	and f.salario > f2.salario
	);
	
-- Liste os nomes dos departamentos que n√£o possuem funcion√°rios.

select 
	d.nome_departamento
from 
	departamentos d
where not exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	);


--üß™ Enunciados: Subqueries N√£o Correlacionadas
-- Liste os nomes dos funcion√°rios que ganham mais que a m√©dia salarial geral da empresa.


select 
	f.nome_funcionario,
	f.salario
from 
	funcionarios f
where 
	f.salario > (
	select AVG(f2.salario)
	from funcionarios f2
	);




select 
	f.nome_funcionario
from 
	funcionarios f
where salario > (
	select avg(f2.salario)
	from funcionarios f2
	);

-- Liste os nomes dos departamentos cujo nome come√ßa com a mesma letra que o nome do funcion√°rio com maior sal√°rio.


select 
	d.nome_departamento
from
	departamentos d
where 
	LEFT(d.nome_departamento, 1) = (
	select top 1 LEFT(f.nome_funcionario, 1)
	from funcionarios f
	order by f.salario desc
	);


SELECT d.nome_departamento
FROM departamentos d
WHERE LEFT(d.nome_departamento, 1) = (
    SELECT TOP 1 LEFT(f.nome_funcionario, 1)
    FROM funcionarios f
    ORDER BY f.salario DESC
);

-- Liste os nomes dos funcion√°rios cujo sal√°rio √© igual ao menor sal√°rio da empresa.

select 
	f.nome_funcionario
from 
	funcionarios f
where 
	f.salario = (
	select MIN(f2.salario)
	from funcionarios f2
	);


SELECT f.nome_funcionario
FROM funcionarios f
WHERE f.salario = (
    SELECT MIN(f2.salario)
    FROM funcionarios f2
);

-- Liste os nomes dos departamentos onde o maior sal√°rio da empresa √© maior que 20 mil.


select 
	d.nome_departamento
from 
	departamentos d
where (
	select MAX(salario)
	from funcionarios 
	) > 7500;


SELECT d.nome_departamento
FROM departamentos d
WHERE (
    SELECT MAX(salario)
    FROM funcionarios
) > 7000;

-- Liste os nomes dos funcion√°rios que ganham menos que o maior sal√°rio da empresa.

select 
	f.nome_funcionario
from 
	funcionarios f
where 
	f.salario < (
	select max(f2.salario)
	from funcionarios f2
	);
	

SELECT f.nome_funcionario
FROM funcionarios f
WHERE f.salario < (
    SELECT MAX(f2.salario)
    FROM funcionarios f2
);


--üß™ Enunciados: Subqueries Correlacionadas
--1. 	Liste os nomes dos departamentos onde nenhum funcion√°rio ganha mais que 10 mil.


select 
	d.nome_departamento
from 
	departamentos d
where 
	not exists (
	select f.nome_funcionario
	from funcionarios f
	where d.id_departamento = f.id_departamento
	and f.salario > 7000
	);



select 
	d.nome_departamento
from 
	departamentos d
where not exists (
	select f.id_departamento
	from funcionarios f
	where f.id_departamento = d.id_departamento
	);

--2. 	Liste os nomes dos funcion√°rios que ganham mais que a m√©dia salarial do seu pr√≥prio departamento.


select 
	f.nome_funcionario
from 
	funcionarios f
where 
	f.salario > (
		select AVG(f2.salario)
		from funcionarios f2
		where f.id_departamento = f2.id_departamento
		);


select 
	f.nome_funcionario
from 
	funcionarios f
where f.salario > (
	select avg(f2.salario)
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	);


--3. 	Liste os nomes dos departamentos que possuem pelo menos um funcion√°rio com sal√°rio inferior a 3000.


select 
	d.nome_departamento
from 
	departamentos d
where 
	exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	and f.salario < 3000
	);



select 
	d.nome_departamento
from 
	departamentos d
where exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento 
	and f.salario < 3000
	);


--4. 	Liste os nomes dos funcion√°rios que trabalham em departamentos onde h√° outro funcion√°rio com sal√°rio maior que o deles.


select 
	f.nome_funcionario
from 
	funcionarios f
where 
	exists (
	select f2.nome_funcionario
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	and f.salario > f2.salario
	);



select 
	 f.nome_funcionario
from 
	funcionarios f
where 
	exists (
	select 1
	from funcionarios f2
	where f.id_departamento = f2.id_departamento
	and f.salario > f2.salario
	);


--5. 	Liste os nomes dos departamentos que n√£o possuem funcion√°rios.


select 
	d.nome_departamento
from 
	departamentos d
where 
	not exists (
	select 1
	from funcionarios f
	where d.id_departamento = f.id_departamento
	);

select 
	d.nome_departamento
from
	departamentos d
where 
	not exists (
		select 1
		from funcionarios f
		where d.id_departamento = f.id_departamento
		);


--üß™ Enunciados: Subqueries N√£o Correlacionadas
--6. 	Liste os nomes dos funcion√°rios que ganham mais que a m√©dia salarial geral da empresa.


select 
	f.nome_funcionario
from 
	funcionarios f
where 
	f.salario > (
	select AVG(salario)
	from funcionarios
	);



select 
	f.nome_funcionario
from 
	funcionarios f
where f.salario > (
	select AVG(salario)
	from funcionarios
	);
	
--7. Liste os nomes dos departamentos cujo nome come√ßa com a mesma letra que o nome do funcion√°rio com maior sal√°rio.

select 
	d.nome_departamento
from 
	departamentos d
where LEFT(d.nome_departamento, 1) = (
	select top 1 LEFT(f.nome_funcionario, 1)
	from funcionarios f
	order by f.salario desc
	);
	

select 
	d.nome_departamento
from
	departamentos d
where left(d.nome_departamento, 1) = (
	select top 1 LEFT(f.nome_funcionario, 1) 
	from funcionarios f
	order by f.salario desc
	);

--8. 	Liste os nomes dos funcion√°rios cujo sal√°rio √© igual ao menor sal√°rio da empresa.

select 
	f.nome_funcionario
from 
	funcionarios f
where f.salario = (
	select MIN(salario)
	from funcionarios
	);


select 
	f.nome_funcionario
from	
	funcionarios f
where f.salario = (
	select MIN(salario)
	from funcionarios
	);

--9. Liste os nomes dos departamentos onde o maior sal√°rio da empresa √© maior que 7 mil.

select 
	d.nome_departamento
from 
	departamentos d
where (
	select MAX(f.salario)
	from funcionarios f
	) > 7000;


SELECT d.nome_departamento
FROM departamentos d
WHERE (
    SELECT MAX(salario)
    FROM funcionarios
) > 7000;
--10. Liste os nomes dos funcion√°rios que ganham menos que o maior sal√°rio da empresa.


select 
	f.nome_funcionario
from 
	funcionarios f
where 
	f.salario < (
	select MAX(salario)
	from funcionarios
	);



select 
	f.nome_funcionario
from 
	funcionarios f
where f.salario < (
	select MAX(salario)
	from funcionarios
	);


--Tipos de dados - Data types

| Tipo                            | Descri√ß√£o                                        | Observa√ß√µes                      |
| ------------------------------- | ------------------------------------------------ | -------------------------------- |
| `INT` / `INTEGER`               | N√∫mero inteiro comum                             | Pode ser `SIGNED` ou `UNSIGNED`  |
| `SMALLINT`                      | Inteiro menor (menos espa√ßo de armazenamento)    | Ideal para valores de 0 a 32.000 |
| `BIGINT`                        | Inteiro maior (n√∫meros muito grandes)            | At√© 9 quintilh√µes (64 bits)      |
| `DECIMAL(p,s)` / `NUMERIC(p,s)` | N√∫meros exatos com casas decimais (ex: dinheiro) | `p = precis√£o`, `s = escala`     |
| `FLOAT`                         | N√∫mero com ponto flutuante (aproxima√ß√£o)         | Mais r√°pido, menos preciso       |
| `REAL`                          | Similar ao `FLOAT`, varia√ß√£o por SGBD            | Aproxima√ß√£o, sujeito a erro      |
| `DOUBLE PRECISION`              | Mais precis√£o que `FLOAT` e `REAL`               | Usado para c√°lculos cient√≠ficos  |


| Tipo        | Descri√ß√£o                                      | Observa√ß√µes                                 |
| ----------- | ---------------------------------------------- | ------------------------------------------- |
| `DATE`      | Apenas data (`AAAA-MM-DD`)                     | Ex: `'2025-08-17'`                          |
| `TIME`      | Apenas hora (`HH:MM:SS`)                       | Ex: `'13:45:00'`                            |
| `DATETIME`  | Data e hora (sem fuso hor√°rio)                 | MySQL usa `DATETIME`                        |
| `TIMESTAMP` | Data e hora com marca temporal (pode ter fuso) | PostgreSQL usa `TIMESTAMP [WITH] TIME ZONE` |
| `YEAR`      | Apenas ano (dispon√≠vel no MySQL)               | Ex: `2025`                                  |



| Tipo             | Descri√ß√£o                                    | Observa√ß√µes                                |
| ---------------- | -------------------------------------------- | ------------------------------------------ |
| `CHAR(n)`        | Texto fixo com `n` caracteres                | Ocupa sempre o mesmo espa√ßo                |
| `VARCHAR(n)`     | Texto vari√°vel com at√© `n` caracteres        | Mais eficiente que `CHAR`                  |
| `TEXT`           | Texto longo (varia por SGBD)                 | Ideal para descri√ß√µes e textos grandes     |
| `NVARCHAR(n)`    | Suporte a **Unicode (caracteres especiais)** | SQL Server/PostgreSQL                      |
| `CLOB` / `NCLOB` | Texto muito longo (Character Large Object)   | Armazenado fora da tabela em alguns bancos |


| Tipo      | Descri√ß√£o                           | Observa√ß√µes                                  |
| --------- | ----------------------------------- | -------------------------------------------- |
| `BOOLEAN` | Aceita `TRUE`, `FALSE`, ou `NULL`   | Em MySQL, pode ser tratado como `TINYINT(1)` |
| `ENUM`    | Conjunto fixo de valores permitidos | MySQL nativamente; simulado em outros bancos |
| `SET`     | Conjunto de m√∫ltiplas escolhas      | Exclusivo do MySQL                           |
| `UUID`    | Identificador √∫nico universal       | Comum em PostgreSQL                          |
| `JSON`    | Armazena dados em formato JSON      | PostgreSQL, MySQL e SQL Server suportam      |
| `XML`     | Armazena dados estruturados em XML  | Suportado principalmente no SQL Server       |


| Tipo           | Descri√ß√£o                               |
| -------------- | --------------------------------------- |
| `BINARY(n)`    | Cadeia bin√°ria fixa                     |
| `VARBINARY(n)` | Cadeia bin√°ria vari√°vel                 |
| `BLOB`         | Binary Large Object ‚Äî arquivos, imagens |


--------------------------------------------------------------------------------------------------

--O Case When √© como um "if-else" dentro do SQL. 
--Ele permite criar condi√ß√µes e retornar valores diferentes dependendo do que acontece.

select 
	f.nome_funcionario,
	f.salario,
	case
		when f.salario < 6000 then 'Salario baixo'
		when f.salario between 6001 and 7000 then 'Salario m√©dio'
		else 'Salario alto'
	end as faixa_salarial
from funcionarios f;


--Introdu√ß√£o ao CTE (Common Table Expression)
--O CTE √© uma express√£o de tabela tempor√°ria que voc√™ define no in√≠cio da consulta. Ele ajuda a organizar o c√≥digo, evitar subqueries repetidas, e facilita a leitura.
--üìå Estrutura b√°sica:

WITH vendas_por_cliente AS (
  SELECT cliente_id, SUM(valor) AS total_vendas
  FROM vendas
  GROUP BY cliente_id
)
SELECT
  c.nome,
  v.total_vendas
FROM clientes c
JOIN vendas_por_cliente v ON c.id = v.cliente_id;

/*
üß† Como pensar no CTE:
- Imagine que voc√™ est√° criando uma tabela tempor√°ria chamada vendas_por_cliente
- Depois, voc√™ pode us√°-la como se fosse uma tabela normal na consulta principal
‚úÖ Vantagens:
- Organiza√ß√£o: separa etapas complexas em blocos
- Reutiliza√ß√£o: evita repetir subqueries
- Leitura f√°cil: especialmente √∫til em an√°lises mais avan√ßadas

üß™ Quer praticar?
Posso te propor um exerc√≠cio com CASE WHEN e outro com CTE, ou at√© combinar os dois em um desafio s√≥.
Voc√™ prefere come√ßar com um exemplo simples ou j√° quer um cen√°rio mais realista, tipo an√°lise de vendas, desempenho de alunos, ou algo que se relacione com seu dia a dia?
Voc√™ manda! üòé
*/


With vendas_por_cliente as (
	select cliente_id, sum(valor) as total_vendas
	from vendas 
	group by cliente_id
)
select 
	c.nome,
	v.total_vendas
from clientes c
join vendas_por_cliente v on c.id = v.cliente_id;


with vendas_por_cliente as (
	select 
		cliente_id, 
		sum(valor) as total_vendas
	from 
		vendas
	group by
		cliente_id
	)
	select 
		c.nome,
		v.total_vendas
	from 
		clientes c
	join vendas_por_cliente v on c.id = v.cliente_id;


	

-- Exerc√≠cios de Case When

--Classifique os funcion√°rios como:
--Baixo sal√°rio se ganham menos do 3000
--M√©dio sal√°rio se entre 3001 e 7000
--Alto sal√°rio acima de 7001

select 
f.nome_funcionario,
f.salario,
Case
	When salario < 3000 then 'Baixo'
	When salario between 3001 and 7000 then 'M√©dio'
	Else 'Alto'
End as Class
from 
funcionarios f;
	

--Crie uma coluna que diga "Sim" se o funcion√°rio estiver alocado em algum departamento, e "N√£o" se n√£o estiver.
--Tabela: funcionarios
--Campo: id_departamento (pode ser nulo)

select 
	f.nome_funcionario,
case 
	when id_departamento between 0 and 1000000 then 'Sim'
	else 'N√£o'
end as Aloc
from 
	funcionarios f; 

	
select f.nome_funcionario,
case
	when id_departamento is null then 'N√£o'
	else 'Sim'
end as Alc
from funcionarios f;


--Classifique os departamentos como:
--‚Ä¢ 	"Vazio" se n√£o tiverem funcion√°rios
--‚Ä¢ 	"Ativo" se tiverem pelo menos um funcion√°rio

select 
	d.nome_departamento,
case 
	when f.id_departamento is null then 'Vazio'
	else 'Ativo'
end as Class
from departamentos d 
full join funcionarios f on d.id_departamento = f.id_departamento;


--Crie uma coluna que diga "Acima da m√©dia" ou "Abaixo da m√©dia" 
--comparando o sal√°rio de cada funcion√°rio com a m√©dia geral da empresa.

select
	f.salario,
case 
	when f.salario > (select AVG(salario) from funcionarios) then 'Acima da m√©dia'
	else 'Abaixo da m√©dia'
end as Med 
from 
	funcionarios f
group by 
	f.salario;


 --Crie uma coluna que diga "Mesmo departamento" ou "Outro departamento" comparando o 
 --departamento de cada funcion√°rio com o do funcion√°rio de maior sal√°rio.

 select 
	f.nome_funcionario,
case 
	when f.id_departamento = f2.id_departamento then 'Mesmo departamento'
	else 'Outro departamento'
end as depar
from funcionarios f
join funcionarios f2 on f.id_departamento = f2.id_departamento
where f.salario > f2.salario;


--üöÄ Exerc√≠cios de CTE
--Crie um CTE que calcule o total de sal√°rio por departamento, e depois mostre o nome do departamento e esse total.


with calc_tt_sal as (
	select 
		f.id_departamento,
		sum(f.salario) tt_salario
	from 
		funcionarios f
	group by 
		f.id_departamento
	) select
		d.nome_departamento,
		c.tt_salario
	 from 
		departamentos d
	join calc_tt_sal c on d.id_departamento = c.id_departamento;
		
	  	
--Crie um CTE que calcule a m√©dia salarial por departamento, 
--e depois liste os funcion√°rios que ganham acima da m√©dia do seu departamento.

with media_dep as (
	select 
		f.id_departamento,
		avg(f.salario) media_sal
	from 
		funcionarios f
	group by f.id_departamento
	) select 
		f2.nome_funcionario,
		m.media_sal
	  from 
		funcionarios f2
	join media_dep m on m.id_departamento = f2.id_departamento
	where f2.salario > m.media_sal;
		


--Crie um CTE que conte quantos funcion√°rios existem por departamento, 
--e depois liste apenas os departamentos com mais de 5 funcion√°rios.



With func_por_dp as (
	select 
		f.id_departamento,
		count(*) qtd_func
	from 
		funcionarios f
	group by 
		f.id_departamento
	) select 
		f2.id_departamento,
		f3.qtd_func
	  from 
		funcionarios f2
	  join func_por_dp f3 on f2.id_departamento = f3.id_departamento
	  where f3.qtd_func > 3
	  group by 
		f2.id_departamento,
		f3.qtd_func;



--Crie um CTE que encontre o menor sal√°rio da empresa, e depois liste os funcion√°rios que ganham esse valor.

With menor_salario as (
	select 
		f.id_departamento,
		min(f.salario) as mn_sal
	from 
		funcionarios f
	group by
		f.id_departamento
	)select 
		f2.id_funcionario,
		f2.salario
	 from 
		funcionarios f2
join menor_salario m on f2.id_departamento = m.id_departamento
	 and f2.salario = m.mn_sal;


--Crie um CTE que calcule a soma de sal√°rios por departamento, 
--e depois classifique os departamentos como "Custos altos" se a soma for maior que R$ 21.000, 
--ou "Custos baixos" se for menor.

with soma_sal as (
	select
		id_departamento,
		sum(salario) soma
	from 
		funcionarios
	group by 
		id_departamento
	) select 
			d.nome_departamento,
		   	s.soma,
		case
		when s.soma > 21000 then 'Custos altos'
		else 'Custos baixos'
	 end as faixa
	 from 
		departamentos d
join soma_sal s on s.id_departamento = d.id_departamento;


--Views 

--1 Crie uma view que liste o nome e sal√°rio de todos os funcion√°rios.

create view info as 
	select 
		nome_funcionario,
		salario
	from 
		funcionarios;

select * from info


--2 Crie uma view que mostre os funcion√°rios com sal√°rio acima de R$ 5000.

create view vw_sal as 
	select 
		nome_funcionario,
		salario
	from 
		funcionarios
	where 
		salario > 5000;

select * from vw_sal

--3 Crie uma view que traga o nome do departamento e a quantidade de funcion√°rios em cada um.

create view qtd_dp as 
	select 
		d.nome_departamento,
		count(f.id_funcionario) cont
	from 
		departamentos d
full join funcionarios f on d.id_departamento = f.id_departamento
group by 
	d.nome_departamento;


select * from qtd_dp



--4 Crie uma view que traga os funcion√°rios que n√£o est√£o alocados em nenhum departamento.

create view n_aloc as 
	select 
		f.nome_funcionario
	from 
		funcionarios f
	where 
		f.id_departamento is null;

--5 Crie uma view que traga o nome do funcion√°rio, o nome do departamento e o sal√°rio.

create view nds as 
	select 
		d.nome_departamento,
		f.nome_funcionario,
		f.salario
	from 
		funcionarios f
join departamentos d on f.id_departamento = d.id_departamento;


--Procedures sem par√¢metros
--Simples ‚Äî Listar todos os funcion√°rios

create procedure sp_listar_funcionarios
as 
begin 
	select nome_funcionario, salario
	from funcionarios;
end;

create procedure Nomedaprocedure
as
begin
 --query
end;


create procedure nomedaprocedure
as
begin
--Query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as 
begin
--query
end;

create procedure nomedaprocedure
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as 
begin
--query
end;


create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;


create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;

create procedure nomedaprocedure
as
begin
--query
end;


create procedure nomedaprocedure
as
begin
--query 
end;

create procedure nomedaprocedure
as
begin
--query
end;


--Listar todos os funcion√°rios

create procedure sp_listar_funcionarios
as 
begin
	select nome_funcionario, salario
	from funcionarios;
end;

create procedure sp_listar_funcionarios
as
begin
	select nome_funcionario, salario
	from funcionarios;
end;


create procedure sp_listar_funcionario
as
begin
	select nome_funcionario, salario
	from funcionarios;
end;


--Mostrar total de sal√°rios por departamento

create procedure sp_total_salario_por_departamento
as
begin
	select
		d.nome_departamento,
		sum(f.salario) as total_salario
	from funcionarios f 
	join departamentos d on f.id_departamento = d.id_departamento
	group by d.nome_departamento;
end;

create procedure sp_total_salario_por_departamento
as
begin
	select 
		d.nome_departamento,
		sum(f.salario) as total_salario
	from funcionarios f
	join departamentos d on f.id_departamento = d.id_departamento
	group by d.nome_departamento;
end;





--Mostrar total de sal√°rios por departamento

create procedure sp_funcionarios_acima_da_media
as
begin
	with media_por_departamento as (
		select id_departamento, avg(salario) as media_salario
		from funcionarios
		group by id_departamento
	)
	select
		f.nome_funcionario,
		f.salario,
		d.nome_departamento,
		m.media_salario
	from funcionarios f
	join media_por_departamento m on f.id_departamento = m.id_departamento
	join departamentos d on f.id_departamento = d.id_departamento
	where f.salario > m.media_salario;
end;



--Procedures com par√¢metros

-- Listar funcion√°rios de um departamento espec√≠fico

creature procedure sp_funcionarios_por_departamento
	@id_dep int
as
begin
	select nome_funcionario, salario
	from funcionarios
	where id_departamento = @id_dep;
end;



--Mostrar total de sal√°rios de um departamento espec√≠fico

create procedure sp_total_salario_departamento
	@id_dep int
as 
begin
	select sum(salario) as total_salario
	from funcionarios
	where id_departamento = @id_dep;
end;


--Listar funcion√°rios com sal√°rio acima de um valor m√≠nimo e de um departamento espec√≠fico

create procedure sp_funcionarios_filtrados
	@id_dep int,
	@salario_min decimal(10,2)
as
begin
	select nome_funcionario, salario
	from funcionarios
	where id_departamento = @id_dep
	and salario > @salario_min;
end;




























































































